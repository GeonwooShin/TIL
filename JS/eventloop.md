# **이벤트 루프**
자바스크립트의 가장 큰 특징을 꼽자면, 싱글 스레드로 동작한다는 것을 뽑을 수 있겠다.  
자바스크립트가 싱글 스레드로 동작하는 반면, 자바스크립트가 동작하는 환경 위에서는 여러가지 스레드가 존재한다고 볼 수 있다.

-----------
## **자바스크립트 엔진**
![자바스크립트엔진](https://ingg.dev/b5a94511e3d3f116f5f9a01fe9e5aed6/work1.svg)
> 이미지 출처 : https://ingg.dev/b5a94511e3d3f116f5f9a01fe9e5aed6/work1.svg

* 메모리 힙 (Memory Heap) : 변수를 선언하여 할당된 데이터들이 저장되는 곳
* 콜 스택 (Call Stack) : 함수를 실행하는 순서에 따라 차곡차곡 쌓아놓는 곳  

**여기에서 알수있는 문제점 : ''지금 까지 알아본 바로는 자바스크립트는 싱글스레드라는 것인데, 처리하는데 시간이 걸리는 것은 블로킹에 걸리지 않고 어떻게 처리하느냐''이다.**  

***이때 등장하는 것이 바로 '이벤트 루프'이다.***

-----------
## **이벤트 루프**
---------------  

타이머 함수, 이벤트 핸들러, HTTP 요청과 같은 Web APIs들은 비동기 처리 방식으로 동작하는데,  

자바스크립트 엔진이 멀티스레드처럼 동작하도록 또 다른 스레드를 지원해주는 것과 같은 기능을 하는 것.  

## **예제)**
```js
console.log('1');

setTimeout(function timeout() {
    console.log('2');
}, 5000);

function foo() {
    console.log('4')
}

console.log('3');

foo()
```
위와 같은 코드에서 이벤트 루프가 없다면 콘솔에 출력되는 순서는  ***1 > 2 > 3 > 4*** 그대로 출력될 것이다.  

**왜냐하면 자바스크립트는 싱글스레드이기 때문에 처리에 시간이 걸리는 setTimeout같은 함수를 실행하는 경우에는 블로킹이 발생하기 때문이다.**

하지만, 이벤트루프가 존재하는 경우에는 콘솔의 출력 결과는  

***1 > 3 > 4 > 2*** 가 된다.  

그 이유를 알아보자.  


### **태스크 큐**  

---------

      1. Web APIs 함수가 실행되면, 콜 스택에 Web APIs 함수가 적재된다.  

      2. 콜 스택에 적재됐던 함수는 Web APIs에 적재되고 타이머를 수행한다.  

      3. 함수는 타이머를 마치게 되면, 태스크 큐에 적재된다.  

      4. 이 때 이벤트 루프는 콜 스택과, 태스크 큐를 주시한다.  
      
      5. 콜 스택에 실행 될 함수가 없다면, 태스크 큐에 있던 함수가 콜 스택에 올라가 실행된다.

그렇다면 Web APIs가 태스크 큐에 적재되는 것 처럼  
Promise와 같은 비동기 처리 방식의 동작 원리는 어떻게 될까?  

핵심은 바로 마이크로 태스크 큐이다.  

## **예제 2)**
```js
function bar() {
  console.log('bar')
}

setTimeout(bar, 0)

Promise.resolve('promise')
  .then((res) => console.log(res))

function foo() {
  console.log('foo')
}

console.log('a')

foo()
```  

위와 같은 코드가 있다고 했을 때 실행 결과는 다음과 같다.  

***a > foo > promise > bar***  

***promise***가 ***bar*** 보다 먼저 콘솔에 출력될 수 있는 이유는 바로, promise와 같은 비동기 처리는 태스크 큐가 아닌 **마이크로 태스크 큐**에 적재되기 때문이다.  

위의 예제의 마이크로 태스크 큐의 동작원리를 살펴보자.

---------

      1. 프로미스가 정상적으로 동작해서 resolve가 되면 등록해논 콜백이 마이크로 
      태스크 큐에 적재된다.  

      2. SetTimeout과 같은 Web APIs는 태스크 큐에 적재된다.  

      3. 콜 스택에서 더 이상 실행할 함수가 없다면 마이크로 태스크 큐에 적재된 
      콜백이 콜 스택에 올라가 실행된다.  

      4. 태스크 큐에 적재된 함수는 마이크로 태스크 큐에 적재되어 있던 콜백들이 모두 
      콜 스택에 쌓여 실행되고 난 후에 콜 스택에 올라가 실행된다.  
      

여기서 알 수 있는 사실은 ***마이크로 태스크 큐는 태스크 큐보다 우선 순위를 가진다***는 것이다.  
또한, 이벤트 루프는 마이크로 태스크 큐의 모든 콜백을 처리해야 태스크 큐를 주시하게 된다.  

따라서, ***태스크 큐에 적재되어 있는 Web APIs는 마이크로 태스크 큐에 적재되어 있는 모든 콜백들이 실행되고 나서야 실행된다.***