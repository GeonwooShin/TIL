# **함수 호이스팅**

[변수 호이스팅](https://github.com/GeonwooShin/TIL/blob/master/JS/variableHoisting.md)에 대해서는 이미 다뤘으니 이번에는, 함수의 호이스팅에 대해 알아보자.

함수 호이스팅을 이해하려면 **함수 정의**에 대한 간단한 사전 지식이 필요하다.

함수 정의는 함수 호출 전에 필요한 매개변수, 실행문, 반환 값들을 지정하는 것인데, 총 4가지가 존재한다.

1. 함수 선언문

2. 함수 표현식

3. 생성자 함수

4. 화살표 함수

이 중에서 **함수 선언문**과 **함수 표현식**을 한 번 비교해서 함수 호이스팅에 대해 알아보려 한다.

---

## **함수 선언문**

---

함수 선언문의 간단한 예시를 들어보면, 아래와 같다.

```js
function foo() {
  console.log("함수 선언문");
}
```

그렇다면 다음 예제를 살펴보자.

### **함수 선언문 예제 1)**

```js
foo();

function foo() {
  console.log("함수 선언문");
}
```

함수 선언문 예제의 출력 결과는 "함수 선언문"이 정상적으로 출력된다.

따라서, 위의 예시에서는 함수 선언문으로 정의한 함수가 맨 위로 끌어올려진 것처럼 동작하는 것을 알 수 있다.

이것을 바로 **_함수 호이스팅_** 이라고 한다.

그렇다면 함수 표현식을 한 번 살펴보자.

---

## **함수 표현식**

---

함수 표현식의 간단한 예시를 들어보면, 아래와 같다.

```js
var foo = function () {
  console.log("함수 표현식");
};
```

그렇다면 다음 예제를 살펴보자.

### **함수 표현식 예제 1)**

```js
foo();

var foo = function () {
  console.log("함수 표현식");
};
```

위의 예제를 살펴보면 먼저 콘솔에 출력되는 결과는 **TypeError** 이다.

이런 결과가 나온 이유는 무엇일까?

저번 변수 호이스팅에서 설명했듯이 var 키워드로 선언된 변수는 선언과 함께 undefined로 초기화된다 설명했다.

또한, 변수 값의 할당은 할당문에서 이루어지기 때문에, 함수 표현식도 할당문에서 함수 객체가 된다.

따라서, 함수 표현식은 함수 리터럴 값이 변수에 할당되는 것이기 때문에 **_함수 표현식은 변수 호이스팅이 발생하는 것과 다름없다고 할 수 있다._**

그렇기 때문에 함수 표현식 전에 함수를 참조하게 되면 undefined의 값이 나오고, 함수를 호출하게 되면 undefined를 호출하는 것이기 때문에 TypeError가 발생하게 된다.

---

### **함수 표현식 예제 2)**

```js
foo();

let foo = function () {
  console.log("함수 표현식");
};
```

위의 예제처럼 함수 표현식을 let 키워드로 담게 되면 어떻게될까?

출력결과는 ReferenceError 이다. 이 출력 결과 또한 변수 호이스팅의 특징이 잘 나타난다.

var을 이용한 함수 표현식은 함수 표현식 이전에 함수를 참조하게 되면 초기화 됐음에도, 값이 할당되지 않았기 때문에 undefined를 출력하지만

let을 이용한 함수 표현식은 선언과 초기화가 함께 진행되지 않기 때문에 ReferenceError 를 출력하게 되는 것이다.
